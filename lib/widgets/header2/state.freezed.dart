// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$Header2State {
  Header2? get header2 => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Header2? header2) empty,
    required TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)
        withModelSettings,
    required TResult Function(Header2 header2, MaterialData material)
        withMaterial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Header2? header2)? empty,
    TResult? Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult? Function(Header2 header2, MaterialData material)? withMaterial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Header2? header2)? empty,
    TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult Function(Header2 header2, MaterialData material)? withMaterial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(Header2StateWithModelSettings value)
        withModelSettings,
    required TResult Function(Header2StateWithMaterial value) withMaterial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult? Function(Header2StateWithMaterial value)? withMaterial,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult Function(Header2StateWithMaterial value)? withMaterial,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $Header2StateCopyWith<Header2State> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $Header2StateCopyWith<$Res> {
  factory $Header2StateCopyWith(
          Header2State value, $Res Function(Header2State) then) =
      _$Header2StateCopyWithImpl<$Res, Header2State>;
  @useResult
  $Res call({Header2 header2});
}

/// @nodoc
class _$Header2StateCopyWithImpl<$Res, $Val extends Header2State>
    implements $Header2StateCopyWith<$Res> {
  _$Header2StateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? header2 = null,
  }) {
    return _then(_value.copyWith(
      header2: null == header2
          ? _value.header2!
          : header2 // ignore: cast_nullable_to_non_nullable
              as Header2,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res>
    implements $Header2StateCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Header2? header2});
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$Header2StateCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? header2 = freezed,
  }) {
    return _then(_$EmptyImpl(
      header2: freezed == header2
          ? _value.header2
          : header2 // ignore: cast_nullable_to_non_nullable
              as Header2?,
    ));
  }
}

/// @nodoc

class _$EmptyImpl implements _Empty {
  const _$EmptyImpl({this.header2});

  @override
  final Header2? header2;

  @override
  String toString() {
    return 'Header2State.empty(header2: $header2)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EmptyImpl &&
            (identical(other.header2, header2) || other.header2 == header2));
  }

  @override
  int get hashCode => Object.hash(runtimeType, header2);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      __$$EmptyImplCopyWithImpl<_$EmptyImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Header2? header2) empty,
    required TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)
        withModelSettings,
    required TResult Function(Header2 header2, MaterialData material)
        withMaterial,
  }) {
    return empty(header2);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Header2? header2)? empty,
    TResult? Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult? Function(Header2 header2, MaterialData material)? withMaterial,
  }) {
    return empty?.call(header2);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Header2? header2)? empty,
    TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult Function(Header2 header2, MaterialData material)? withMaterial,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(header2);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(Header2StateWithModelSettings value)
        withModelSettings,
    required TResult Function(Header2StateWithMaterial value) withMaterial,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult? Function(Header2StateWithMaterial value)? withMaterial,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult Function(Header2StateWithMaterial value)? withMaterial,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _Empty implements Header2State {
  const factory _Empty({final Header2? header2}) = _$EmptyImpl;

  @override
  Header2? get header2;
  @override
  @JsonKey(ignore: true)
  _$$EmptyImplCopyWith<_$EmptyImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Header2StateWithModelSettingsImplCopyWith<$Res>
    implements $Header2StateCopyWith<$Res> {
  factory _$$Header2StateWithModelSettingsImplCopyWith(
          _$Header2StateWithModelSettingsImpl value,
          $Res Function(_$Header2StateWithModelSettingsImpl) then) =
      __$$Header2StateWithModelSettingsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Header2 header2,
      ModelSettings modelSettings,
      ObjectName? objectName,
      CollisionStruct? collisionStruct,
      SelectedChunkState? selectedChunkState});

  $SelectedChunkStateCopyWith<$Res>? get selectedChunkState;
}

/// @nodoc
class __$$Header2StateWithModelSettingsImplCopyWithImpl<$Res>
    extends _$Header2StateCopyWithImpl<$Res,
        _$Header2StateWithModelSettingsImpl>
    implements _$$Header2StateWithModelSettingsImplCopyWith<$Res> {
  __$$Header2StateWithModelSettingsImplCopyWithImpl(
      _$Header2StateWithModelSettingsImpl _value,
      $Res Function(_$Header2StateWithModelSettingsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? header2 = null,
    Object? modelSettings = null,
    Object? objectName = freezed,
    Object? collisionStruct = freezed,
    Object? selectedChunkState = freezed,
  }) {
    return _then(_$Header2StateWithModelSettingsImpl(
      header2: null == header2
          ? _value.header2
          : header2 // ignore: cast_nullable_to_non_nullable
              as Header2,
      modelSettings: null == modelSettings
          ? _value.modelSettings
          : modelSettings // ignore: cast_nullable_to_non_nullable
              as ModelSettings,
      objectName: freezed == objectName
          ? _value.objectName
          : objectName // ignore: cast_nullable_to_non_nullable
              as ObjectName?,
      collisionStruct: freezed == collisionStruct
          ? _value.collisionStruct
          : collisionStruct // ignore: cast_nullable_to_non_nullable
              as CollisionStruct?,
      selectedChunkState: freezed == selectedChunkState
          ? _value.selectedChunkState
          : selectedChunkState // ignore: cast_nullable_to_non_nullable
              as SelectedChunkState?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $SelectedChunkStateCopyWith<$Res>? get selectedChunkState {
    if (_value.selectedChunkState == null) {
      return null;
    }

    return $SelectedChunkStateCopyWith<$Res>(_value.selectedChunkState!,
        (value) {
      return _then(_value.copyWith(selectedChunkState: value));
    });
  }
}

/// @nodoc

class _$Header2StateWithModelSettingsImpl
    implements Header2StateWithModelSettings {
  const _$Header2StateWithModelSettingsImpl(
      {required this.header2,
      required this.modelSettings,
      this.objectName,
      this.collisionStruct,
      this.selectedChunkState});

  @override
  final Header2 header2;
  @override
  final ModelSettings modelSettings;
  @override
  final ObjectName? objectName;
  @override
  final CollisionStruct? collisionStruct;
  @override
  final SelectedChunkState? selectedChunkState;

  @override
  String toString() {
    return 'Header2State.withModelSettings(header2: $header2, modelSettings: $modelSettings, objectName: $objectName, collisionStruct: $collisionStruct, selectedChunkState: $selectedChunkState)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Header2StateWithModelSettingsImpl &&
            (identical(other.header2, header2) || other.header2 == header2) &&
            (identical(other.modelSettings, modelSettings) ||
                other.modelSettings == modelSettings) &&
            (identical(other.objectName, objectName) ||
                other.objectName == objectName) &&
            (identical(other.collisionStruct, collisionStruct) ||
                other.collisionStruct == collisionStruct) &&
            (identical(other.selectedChunkState, selectedChunkState) ||
                other.selectedChunkState == selectedChunkState));
  }

  @override
  int get hashCode => Object.hash(runtimeType, header2, modelSettings,
      objectName, collisionStruct, selectedChunkState);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Header2StateWithModelSettingsImplCopyWith<
          _$Header2StateWithModelSettingsImpl>
      get copyWith => __$$Header2StateWithModelSettingsImplCopyWithImpl<
          _$Header2StateWithModelSettingsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Header2? header2) empty,
    required TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)
        withModelSettings,
    required TResult Function(Header2 header2, MaterialData material)
        withMaterial,
  }) {
    return withModelSettings(header2, modelSettings, objectName,
        collisionStruct, selectedChunkState);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Header2? header2)? empty,
    TResult? Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult? Function(Header2 header2, MaterialData material)? withMaterial,
  }) {
    return withModelSettings?.call(header2, modelSettings, objectName,
        collisionStruct, selectedChunkState);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Header2? header2)? empty,
    TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult Function(Header2 header2, MaterialData material)? withMaterial,
    required TResult orElse(),
  }) {
    if (withModelSettings != null) {
      return withModelSettings(header2, modelSettings, objectName,
          collisionStruct, selectedChunkState);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(Header2StateWithModelSettings value)
        withModelSettings,
    required TResult Function(Header2StateWithMaterial value) withMaterial,
  }) {
    return withModelSettings(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult? Function(Header2StateWithMaterial value)? withMaterial,
  }) {
    return withModelSettings?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult Function(Header2StateWithMaterial value)? withMaterial,
    required TResult orElse(),
  }) {
    if (withModelSettings != null) {
      return withModelSettings(this);
    }
    return orElse();
  }
}

abstract class Header2StateWithModelSettings implements Header2State {
  const factory Header2StateWithModelSettings(
          {required final Header2 header2,
          required final ModelSettings modelSettings,
          final ObjectName? objectName,
          final CollisionStruct? collisionStruct,
          final SelectedChunkState? selectedChunkState}) =
      _$Header2StateWithModelSettingsImpl;

  @override
  Header2 get header2;
  ModelSettings get modelSettings;
  ObjectName? get objectName;
  CollisionStruct? get collisionStruct;
  SelectedChunkState? get selectedChunkState;
  @override
  @JsonKey(ignore: true)
  _$$Header2StateWithModelSettingsImplCopyWith<
          _$Header2StateWithModelSettingsImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$Header2StateWithMaterialImplCopyWith<$Res>
    implements $Header2StateCopyWith<$Res> {
  factory _$$Header2StateWithMaterialImplCopyWith(
          _$Header2StateWithMaterialImpl value,
          $Res Function(_$Header2StateWithMaterialImpl) then) =
      __$$Header2StateWithMaterialImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({Header2 header2, MaterialData material});
}

/// @nodoc
class __$$Header2StateWithMaterialImplCopyWithImpl<$Res>
    extends _$Header2StateCopyWithImpl<$Res, _$Header2StateWithMaterialImpl>
    implements _$$Header2StateWithMaterialImplCopyWith<$Res> {
  __$$Header2StateWithMaterialImplCopyWithImpl(
      _$Header2StateWithMaterialImpl _value,
      $Res Function(_$Header2StateWithMaterialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? header2 = null,
    Object? material = null,
  }) {
    return _then(_$Header2StateWithMaterialImpl(
      header2: null == header2
          ? _value.header2
          : header2 // ignore: cast_nullable_to_non_nullable
              as Header2,
      material: null == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as MaterialData,
    ));
  }
}

/// @nodoc

class _$Header2StateWithMaterialImpl implements Header2StateWithMaterial {
  const _$Header2StateWithMaterialImpl(
      {required this.header2, required this.material});

  @override
  final Header2 header2;
  @override
  final MaterialData material;

  @override
  String toString() {
    return 'Header2State.withMaterial(header2: $header2, material: $material)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Header2StateWithMaterialImpl &&
            (identical(other.header2, header2) || other.header2 == header2) &&
            (identical(other.material, material) ||
                other.material == material));
  }

  @override
  int get hashCode => Object.hash(runtimeType, header2, material);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$Header2StateWithMaterialImplCopyWith<_$Header2StateWithMaterialImpl>
      get copyWith => __$$Header2StateWithMaterialImplCopyWithImpl<
          _$Header2StateWithMaterialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Header2? header2) empty,
    required TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)
        withModelSettings,
    required TResult Function(Header2 header2, MaterialData material)
        withMaterial,
  }) {
    return withMaterial(header2, material);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Header2? header2)? empty,
    TResult? Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult? Function(Header2 header2, MaterialData material)? withMaterial,
  }) {
    return withMaterial?.call(header2, material);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Header2? header2)? empty,
    TResult Function(
            Header2 header2,
            ModelSettings modelSettings,
            ObjectName? objectName,
            CollisionStruct? collisionStruct,
            SelectedChunkState? selectedChunkState)?
        withModelSettings,
    TResult Function(Header2 header2, MaterialData material)? withMaterial,
    required TResult orElse(),
  }) {
    if (withMaterial != null) {
      return withMaterial(header2, material);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(Header2StateWithModelSettings value)
        withModelSettings,
    required TResult Function(Header2StateWithMaterial value) withMaterial,
  }) {
    return withMaterial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult? Function(Header2StateWithMaterial value)? withMaterial,
  }) {
    return withMaterial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(Header2StateWithModelSettings value)? withModelSettings,
    TResult Function(Header2StateWithMaterial value)? withMaterial,
    required TResult orElse(),
  }) {
    if (withMaterial != null) {
      return withMaterial(this);
    }
    return orElse();
  }
}

abstract class Header2StateWithMaterial implements Header2State {
  const factory Header2StateWithMaterial(
      {required final Header2 header2,
      required final MaterialData material}) = _$Header2StateWithMaterialImpl;

  @override
  Header2 get header2;
  MaterialData get material;
  @override
  @JsonKey(ignore: true)
  _$$Header2StateWithMaterialImplCopyWith<_$Header2StateWithMaterialImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SelectedChunkState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SkeletonChunk skeleton, Bone? bone) withSkeleton,
    required TResult Function(LinkChunk linkChunk) withLink,
    required TResult Function(
            MeshChunk mesh, MaterialData? material, Submesh? submesh)
        withMesh,
    required TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)
        withCloth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult? Function(LinkChunk linkChunk)? withLink,
    TResult? Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult? Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult Function(LinkChunk linkChunk)? withLink,
    TResult Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SelectedChunkStateWithSkeleton value)
        withSkeleton,
    required TResult Function(SelectedChunkStateWithLink value) withLink,
    required TResult Function(SelectedChunkStateWithMesh value) withMesh,
    required TResult Function(SelectedChunkStateWithCloth value) withCloth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult? Function(SelectedChunkStateWithLink value)? withLink,
    TResult? Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult? Function(SelectedChunkStateWithCloth value)? withCloth,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult Function(SelectedChunkStateWithLink value)? withLink,
    TResult Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult Function(SelectedChunkStateWithCloth value)? withCloth,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SelectedChunkStateCopyWith<$Res> {
  factory $SelectedChunkStateCopyWith(
          SelectedChunkState value, $Res Function(SelectedChunkState) then) =
      _$SelectedChunkStateCopyWithImpl<$Res, SelectedChunkState>;
}

/// @nodoc
class _$SelectedChunkStateCopyWithImpl<$Res, $Val extends SelectedChunkState>
    implements $SelectedChunkStateCopyWith<$Res> {
  _$SelectedChunkStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SelectedChunkStateWithSkeletonImplCopyWith<$Res> {
  factory _$$SelectedChunkStateWithSkeletonImplCopyWith(
          _$SelectedChunkStateWithSkeletonImpl value,
          $Res Function(_$SelectedChunkStateWithSkeletonImpl) then) =
      __$$SelectedChunkStateWithSkeletonImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SkeletonChunk skeleton, Bone? bone});
}

/// @nodoc
class __$$SelectedChunkStateWithSkeletonImplCopyWithImpl<$Res>
    extends _$SelectedChunkStateCopyWithImpl<$Res,
        _$SelectedChunkStateWithSkeletonImpl>
    implements _$$SelectedChunkStateWithSkeletonImplCopyWith<$Res> {
  __$$SelectedChunkStateWithSkeletonImplCopyWithImpl(
      _$SelectedChunkStateWithSkeletonImpl _value,
      $Res Function(_$SelectedChunkStateWithSkeletonImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? skeleton = null,
    Object? bone = freezed,
  }) {
    return _then(_$SelectedChunkStateWithSkeletonImpl(
      skeleton: null == skeleton
          ? _value.skeleton
          : skeleton // ignore: cast_nullable_to_non_nullable
              as SkeletonChunk,
      bone: freezed == bone
          ? _value.bone
          : bone // ignore: cast_nullable_to_non_nullable
              as Bone?,
    ));
  }
}

/// @nodoc

class _$SelectedChunkStateWithSkeletonImpl
    implements SelectedChunkStateWithSkeleton {
  const _$SelectedChunkStateWithSkeletonImpl(
      {required this.skeleton, this.bone});

  @override
  final SkeletonChunk skeleton;
  @override
  final Bone? bone;

  @override
  String toString() {
    return 'SelectedChunkState.withSkeleton(skeleton: $skeleton, bone: $bone)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedChunkStateWithSkeletonImpl &&
            (identical(other.skeleton, skeleton) ||
                other.skeleton == skeleton) &&
            (identical(other.bone, bone) || other.bone == bone));
  }

  @override
  int get hashCode => Object.hash(runtimeType, skeleton, bone);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectedChunkStateWithSkeletonImplCopyWith<
          _$SelectedChunkStateWithSkeletonImpl>
      get copyWith => __$$SelectedChunkStateWithSkeletonImplCopyWithImpl<
          _$SelectedChunkStateWithSkeletonImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SkeletonChunk skeleton, Bone? bone) withSkeleton,
    required TResult Function(LinkChunk linkChunk) withLink,
    required TResult Function(
            MeshChunk mesh, MaterialData? material, Submesh? submesh)
        withMesh,
    required TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)
        withCloth,
  }) {
    return withSkeleton(skeleton, bone);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult? Function(LinkChunk linkChunk)? withLink,
    TResult? Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult? Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
  }) {
    return withSkeleton?.call(skeleton, bone);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult Function(LinkChunk linkChunk)? withLink,
    TResult Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
    required TResult orElse(),
  }) {
    if (withSkeleton != null) {
      return withSkeleton(skeleton, bone);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SelectedChunkStateWithSkeleton value)
        withSkeleton,
    required TResult Function(SelectedChunkStateWithLink value) withLink,
    required TResult Function(SelectedChunkStateWithMesh value) withMesh,
    required TResult Function(SelectedChunkStateWithCloth value) withCloth,
  }) {
    return withSkeleton(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult? Function(SelectedChunkStateWithLink value)? withLink,
    TResult? Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult? Function(SelectedChunkStateWithCloth value)? withCloth,
  }) {
    return withSkeleton?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult Function(SelectedChunkStateWithLink value)? withLink,
    TResult Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult Function(SelectedChunkStateWithCloth value)? withCloth,
    required TResult orElse(),
  }) {
    if (withSkeleton != null) {
      return withSkeleton(this);
    }
    return orElse();
  }
}

abstract class SelectedChunkStateWithSkeleton implements SelectedChunkState {
  const factory SelectedChunkStateWithSkeleton(
      {required final SkeletonChunk skeleton,
      final Bone? bone}) = _$SelectedChunkStateWithSkeletonImpl;

  SkeletonChunk get skeleton;
  Bone? get bone;
  @JsonKey(ignore: true)
  _$$SelectedChunkStateWithSkeletonImplCopyWith<
          _$SelectedChunkStateWithSkeletonImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectedChunkStateWithLinkImplCopyWith<$Res> {
  factory _$$SelectedChunkStateWithLinkImplCopyWith(
          _$SelectedChunkStateWithLinkImpl value,
          $Res Function(_$SelectedChunkStateWithLinkImpl) then) =
      __$$SelectedChunkStateWithLinkImplCopyWithImpl<$Res>;
  @useResult
  $Res call({LinkChunk linkChunk});
}

/// @nodoc
class __$$SelectedChunkStateWithLinkImplCopyWithImpl<$Res>
    extends _$SelectedChunkStateCopyWithImpl<$Res,
        _$SelectedChunkStateWithLinkImpl>
    implements _$$SelectedChunkStateWithLinkImplCopyWith<$Res> {
  __$$SelectedChunkStateWithLinkImplCopyWithImpl(
      _$SelectedChunkStateWithLinkImpl _value,
      $Res Function(_$SelectedChunkStateWithLinkImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? linkChunk = null,
  }) {
    return _then(_$SelectedChunkStateWithLinkImpl(
      linkChunk: null == linkChunk
          ? _value.linkChunk
          : linkChunk // ignore: cast_nullable_to_non_nullable
              as LinkChunk,
    ));
  }
}

/// @nodoc

class _$SelectedChunkStateWithLinkImpl implements SelectedChunkStateWithLink {
  const _$SelectedChunkStateWithLinkImpl({required this.linkChunk});

  @override
  final LinkChunk linkChunk;

  @override
  String toString() {
    return 'SelectedChunkState.withLink(linkChunk: $linkChunk)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedChunkStateWithLinkImpl &&
            (identical(other.linkChunk, linkChunk) ||
                other.linkChunk == linkChunk));
  }

  @override
  int get hashCode => Object.hash(runtimeType, linkChunk);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectedChunkStateWithLinkImplCopyWith<_$SelectedChunkStateWithLinkImpl>
      get copyWith => __$$SelectedChunkStateWithLinkImplCopyWithImpl<
          _$SelectedChunkStateWithLinkImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SkeletonChunk skeleton, Bone? bone) withSkeleton,
    required TResult Function(LinkChunk linkChunk) withLink,
    required TResult Function(
            MeshChunk mesh, MaterialData? material, Submesh? submesh)
        withMesh,
    required TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)
        withCloth,
  }) {
    return withLink(linkChunk);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult? Function(LinkChunk linkChunk)? withLink,
    TResult? Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult? Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
  }) {
    return withLink?.call(linkChunk);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult Function(LinkChunk linkChunk)? withLink,
    TResult Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
    required TResult orElse(),
  }) {
    if (withLink != null) {
      return withLink(linkChunk);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SelectedChunkStateWithSkeleton value)
        withSkeleton,
    required TResult Function(SelectedChunkStateWithLink value) withLink,
    required TResult Function(SelectedChunkStateWithMesh value) withMesh,
    required TResult Function(SelectedChunkStateWithCloth value) withCloth,
  }) {
    return withLink(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult? Function(SelectedChunkStateWithLink value)? withLink,
    TResult? Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult? Function(SelectedChunkStateWithCloth value)? withCloth,
  }) {
    return withLink?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult Function(SelectedChunkStateWithLink value)? withLink,
    TResult Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult Function(SelectedChunkStateWithCloth value)? withCloth,
    required TResult orElse(),
  }) {
    if (withLink != null) {
      return withLink(this);
    }
    return orElse();
  }
}

abstract class SelectedChunkStateWithLink implements SelectedChunkState {
  const factory SelectedChunkStateWithLink(
      {required final LinkChunk linkChunk}) = _$SelectedChunkStateWithLinkImpl;

  LinkChunk get linkChunk;
  @JsonKey(ignore: true)
  _$$SelectedChunkStateWithLinkImplCopyWith<_$SelectedChunkStateWithLinkImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectedChunkStateWithMeshImplCopyWith<$Res> {
  factory _$$SelectedChunkStateWithMeshImplCopyWith(
          _$SelectedChunkStateWithMeshImpl value,
          $Res Function(_$SelectedChunkStateWithMeshImpl) then) =
      __$$SelectedChunkStateWithMeshImplCopyWithImpl<$Res>;
  @useResult
  $Res call({MeshChunk mesh, MaterialData? material, Submesh? submesh});
}

/// @nodoc
class __$$SelectedChunkStateWithMeshImplCopyWithImpl<$Res>
    extends _$SelectedChunkStateCopyWithImpl<$Res,
        _$SelectedChunkStateWithMeshImpl>
    implements _$$SelectedChunkStateWithMeshImplCopyWith<$Res> {
  __$$SelectedChunkStateWithMeshImplCopyWithImpl(
      _$SelectedChunkStateWithMeshImpl _value,
      $Res Function(_$SelectedChunkStateWithMeshImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mesh = null,
    Object? material = freezed,
    Object? submesh = freezed,
  }) {
    return _then(_$SelectedChunkStateWithMeshImpl(
      mesh: null == mesh
          ? _value.mesh
          : mesh // ignore: cast_nullable_to_non_nullable
              as MeshChunk,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as MaterialData?,
      submesh: freezed == submesh
          ? _value.submesh
          : submesh // ignore: cast_nullable_to_non_nullable
              as Submesh?,
    ));
  }
}

/// @nodoc

class _$SelectedChunkStateWithMeshImpl implements SelectedChunkStateWithMesh {
  const _$SelectedChunkStateWithMeshImpl(
      {required this.mesh, this.material, this.submesh});

  @override
  final MeshChunk mesh;
  @override
  final MaterialData? material;
  @override
  final Submesh? submesh;

  @override
  String toString() {
    return 'SelectedChunkState.withMesh(mesh: $mesh, material: $material, submesh: $submesh)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedChunkStateWithMeshImpl &&
            (identical(other.mesh, mesh) || other.mesh == mesh) &&
            (identical(other.material, material) ||
                other.material == material) &&
            (identical(other.submesh, submesh) || other.submesh == submesh));
  }

  @override
  int get hashCode => Object.hash(runtimeType, mesh, material, submesh);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectedChunkStateWithMeshImplCopyWith<_$SelectedChunkStateWithMeshImpl>
      get copyWith => __$$SelectedChunkStateWithMeshImplCopyWithImpl<
          _$SelectedChunkStateWithMeshImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SkeletonChunk skeleton, Bone? bone) withSkeleton,
    required TResult Function(LinkChunk linkChunk) withLink,
    required TResult Function(
            MeshChunk mesh, MaterialData? material, Submesh? submesh)
        withMesh,
    required TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)
        withCloth,
  }) {
    return withMesh(mesh, material, submesh);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult? Function(LinkChunk linkChunk)? withLink,
    TResult? Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult? Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
  }) {
    return withMesh?.call(mesh, material, submesh);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult Function(LinkChunk linkChunk)? withLink,
    TResult Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
    required TResult orElse(),
  }) {
    if (withMesh != null) {
      return withMesh(mesh, material, submesh);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SelectedChunkStateWithSkeleton value)
        withSkeleton,
    required TResult Function(SelectedChunkStateWithLink value) withLink,
    required TResult Function(SelectedChunkStateWithMesh value) withMesh,
    required TResult Function(SelectedChunkStateWithCloth value) withCloth,
  }) {
    return withMesh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult? Function(SelectedChunkStateWithLink value)? withLink,
    TResult? Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult? Function(SelectedChunkStateWithCloth value)? withCloth,
  }) {
    return withMesh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult Function(SelectedChunkStateWithLink value)? withLink,
    TResult Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult Function(SelectedChunkStateWithCloth value)? withCloth,
    required TResult orElse(),
  }) {
    if (withMesh != null) {
      return withMesh(this);
    }
    return orElse();
  }
}

abstract class SelectedChunkStateWithMesh implements SelectedChunkState {
  const factory SelectedChunkStateWithMesh(
      {required final MeshChunk mesh,
      final MaterialData? material,
      final Submesh? submesh}) = _$SelectedChunkStateWithMeshImpl;

  MeshChunk get mesh;
  MaterialData? get material;
  Submesh? get submesh;
  @JsonKey(ignore: true)
  _$$SelectedChunkStateWithMeshImplCopyWith<_$SelectedChunkStateWithMeshImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SelectedChunkStateWithClothImplCopyWith<$Res> {
  factory _$$SelectedChunkStateWithClothImplCopyWith(
          _$SelectedChunkStateWithClothImpl value,
          $Res Function(_$SelectedChunkStateWithClothImpl) then) =
      __$$SelectedChunkStateWithClothImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ClothChunk cloth, MaterialData? material, Submesh? submesh});
}

/// @nodoc
class __$$SelectedChunkStateWithClothImplCopyWithImpl<$Res>
    extends _$SelectedChunkStateCopyWithImpl<$Res,
        _$SelectedChunkStateWithClothImpl>
    implements _$$SelectedChunkStateWithClothImplCopyWith<$Res> {
  __$$SelectedChunkStateWithClothImplCopyWithImpl(
      _$SelectedChunkStateWithClothImpl _value,
      $Res Function(_$SelectedChunkStateWithClothImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? cloth = null,
    Object? material = freezed,
    Object? submesh = freezed,
  }) {
    return _then(_$SelectedChunkStateWithClothImpl(
      cloth: null == cloth
          ? _value.cloth
          : cloth // ignore: cast_nullable_to_non_nullable
              as ClothChunk,
      material: freezed == material
          ? _value.material
          : material // ignore: cast_nullable_to_non_nullable
              as MaterialData?,
      submesh: freezed == submesh
          ? _value.submesh
          : submesh // ignore: cast_nullable_to_non_nullable
              as Submesh?,
    ));
  }
}

/// @nodoc

class _$SelectedChunkStateWithClothImpl implements SelectedChunkStateWithCloth {
  const _$SelectedChunkStateWithClothImpl(
      {required this.cloth, this.material, this.submesh});

  @override
  final ClothChunk cloth;
  @override
  final MaterialData? material;
  @override
  final Submesh? submesh;

  @override
  String toString() {
    return 'SelectedChunkState.withCloth(cloth: $cloth, material: $material, submesh: $submesh)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SelectedChunkStateWithClothImpl &&
            (identical(other.cloth, cloth) || other.cloth == cloth) &&
            (identical(other.material, material) ||
                other.material == material) &&
            (identical(other.submesh, submesh) || other.submesh == submesh));
  }

  @override
  int get hashCode => Object.hash(runtimeType, cloth, material, submesh);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$SelectedChunkStateWithClothImplCopyWith<_$SelectedChunkStateWithClothImpl>
      get copyWith => __$$SelectedChunkStateWithClothImplCopyWithImpl<
          _$SelectedChunkStateWithClothImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SkeletonChunk skeleton, Bone? bone) withSkeleton,
    required TResult Function(LinkChunk linkChunk) withLink,
    required TResult Function(
            MeshChunk mesh, MaterialData? material, Submesh? submesh)
        withMesh,
    required TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)
        withCloth,
  }) {
    return withCloth(cloth, material, submesh);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult? Function(LinkChunk linkChunk)? withLink,
    TResult? Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult? Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
  }) {
    return withCloth?.call(cloth, material, submesh);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SkeletonChunk skeleton, Bone? bone)? withSkeleton,
    TResult Function(LinkChunk linkChunk)? withLink,
    TResult Function(MeshChunk mesh, MaterialData? material, Submesh? submesh)?
        withMesh,
    TResult Function(
            ClothChunk cloth, MaterialData? material, Submesh? submesh)?
        withCloth,
    required TResult orElse(),
  }) {
    if (withCloth != null) {
      return withCloth(cloth, material, submesh);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SelectedChunkStateWithSkeleton value)
        withSkeleton,
    required TResult Function(SelectedChunkStateWithLink value) withLink,
    required TResult Function(SelectedChunkStateWithMesh value) withMesh,
    required TResult Function(SelectedChunkStateWithCloth value) withCloth,
  }) {
    return withCloth(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult? Function(SelectedChunkStateWithLink value)? withLink,
    TResult? Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult? Function(SelectedChunkStateWithCloth value)? withCloth,
  }) {
    return withCloth?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SelectedChunkStateWithSkeleton value)? withSkeleton,
    TResult Function(SelectedChunkStateWithLink value)? withLink,
    TResult Function(SelectedChunkStateWithMesh value)? withMesh,
    TResult Function(SelectedChunkStateWithCloth value)? withCloth,
    required TResult orElse(),
  }) {
    if (withCloth != null) {
      return withCloth(this);
    }
    return orElse();
  }
}

abstract class SelectedChunkStateWithCloth implements SelectedChunkState {
  const factory SelectedChunkStateWithCloth(
      {required final ClothChunk cloth,
      final MaterialData? material,
      final Submesh? submesh}) = _$SelectedChunkStateWithClothImpl;

  ClothChunk get cloth;
  MaterialData? get material;
  Submesh? get submesh;
  @JsonKey(ignore: true)
  _$$SelectedChunkStateWithClothImplCopyWith<_$SelectedChunkStateWithClothImpl>
      get copyWith => throw _privateConstructorUsedError;
}
