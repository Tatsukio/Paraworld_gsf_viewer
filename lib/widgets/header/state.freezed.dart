// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$HeaderState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)
        withModelInfo,
    required TResult Function(SoundInfo sound) withSound,
    required TResult Function(DustTrailInfo dustTrailInfo) withDustTrail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult? Function(SoundInfo sound)? withSound,
    TResult? Function(DustTrailInfo dustTrailInfo)? withDustTrail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult Function(SoundInfo sound)? withSound,
    TResult Function(DustTrailInfo dustTrailInfo)? withDustTrail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(HeaderStateWithModelInfo value) withModelInfo,
    required TResult Function(HeaderStateWithSound value) withSound,
    required TResult Function(HeaderStateWithDustTrail value) withDustTrail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult? Function(HeaderStateWithSound value)? withSound,
    TResult? Function(HeaderStateWithDustTrail value)? withDustTrail,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult Function(HeaderStateWithSound value)? withSound,
    TResult Function(HeaderStateWithDustTrail value)? withDustTrail,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeaderStateCopyWith<$Res> {
  factory $HeaderStateCopyWith(
          HeaderState value, $Res Function(HeaderState) then) =
      _$HeaderStateCopyWithImpl<$Res, HeaderState>;
}

/// @nodoc
class _$HeaderStateCopyWithImpl<$Res, $Val extends HeaderState>
    implements $HeaderStateCopyWith<$Res> {
  _$HeaderStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$EmptyImplCopyWith<$Res> {
  factory _$$EmptyImplCopyWith(
          _$EmptyImpl value, $Res Function(_$EmptyImpl) then) =
      __$$EmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$EmptyImplCopyWithImpl<$Res>
    extends _$HeaderStateCopyWithImpl<$Res, _$EmptyImpl>
    implements _$$EmptyImplCopyWith<$Res> {
  __$$EmptyImplCopyWithImpl(
      _$EmptyImpl _value, $Res Function(_$EmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$EmptyImpl with DiagnosticableTreeMixin implements _Empty {
  const _$EmptyImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HeaderState.empty()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'HeaderState.empty'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$EmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)
        withModelInfo,
    required TResult Function(SoundInfo sound) withSound,
    required TResult Function(DustTrailInfo dustTrailInfo) withDustTrail,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult? Function(SoundInfo sound)? withSound,
    TResult? Function(DustTrailInfo dustTrailInfo)? withDustTrail,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult Function(SoundInfo sound)? withSound,
    TResult Function(DustTrailInfo dustTrailInfo)? withDustTrail,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(HeaderStateWithModelInfo value) withModelInfo,
    required TResult Function(HeaderStateWithSound value) withSound,
    required TResult Function(HeaderStateWithDustTrail value) withDustTrail,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult? Function(HeaderStateWithSound value)? withSound,
    TResult? Function(HeaderStateWithDustTrail value)? withDustTrail,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult Function(HeaderStateWithSound value)? withSound,
    TResult Function(HeaderStateWithDustTrail value)? withDustTrail,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _Empty implements HeaderState {
  const factory _Empty() = _$EmptyImpl;
}

/// @nodoc
abstract class _$$HeaderStateWithModelInfoImplCopyWith<$Res> {
  factory _$$HeaderStateWithModelInfoImplCopyWith(
          _$HeaderStateWithModelInfoImpl value,
          $Res Function(_$HeaderStateWithModelInfoImpl) then) =
      __$$HeaderStateWithModelInfoImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim});
}

/// @nodoc
class __$$HeaderStateWithModelInfoImplCopyWithImpl<$Res>
    extends _$HeaderStateCopyWithImpl<$Res, _$HeaderStateWithModelInfoImpl>
    implements _$$HeaderStateWithModelInfoImplCopyWith<$Res> {
  __$$HeaderStateWithModelInfoImplCopyWithImpl(
      _$HeaderStateWithModelInfoImpl _value,
      $Res Function(_$HeaderStateWithModelInfoImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? modelInfo = null,
    Object? walkSet = freezed,
    Object? modelAnim = freezed,
  }) {
    return _then(_$HeaderStateWithModelInfoImpl(
      modelInfo: null == modelInfo
          ? _value.modelInfo
          : modelInfo // ignore: cast_nullable_to_non_nullable
              as ModelInfo,
      walkSet: freezed == walkSet
          ? _value.walkSet
          : walkSet // ignore: cast_nullable_to_non_nullable
              as WalkSet?,
      modelAnim: freezed == modelAnim
          ? _value.modelAnim
          : modelAnim // ignore: cast_nullable_to_non_nullable
              as ModelAnim?,
    ));
  }
}

/// @nodoc

class _$HeaderStateWithModelInfoImpl
    with DiagnosticableTreeMixin
    implements HeaderStateWithModelInfo {
  const _$HeaderStateWithModelInfoImpl(
      {required this.modelInfo, this.walkSet, this.modelAnim});

  @override
  final ModelInfo modelInfo;
  @override
  final WalkSet? walkSet;
  @override
  final ModelAnim? modelAnim;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HeaderState.withModelInfo(modelInfo: $modelInfo, walkSet: $walkSet, modelAnim: $modelAnim)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HeaderState.withModelInfo'))
      ..add(DiagnosticsProperty('modelInfo', modelInfo))
      ..add(DiagnosticsProperty('walkSet', walkSet))
      ..add(DiagnosticsProperty('modelAnim', modelAnim));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderStateWithModelInfoImpl &&
            (identical(other.modelInfo, modelInfo) ||
                other.modelInfo == modelInfo) &&
            (identical(other.walkSet, walkSet) || other.walkSet == walkSet) &&
            (identical(other.modelAnim, modelAnim) ||
                other.modelAnim == modelAnim));
  }

  @override
  int get hashCode => Object.hash(runtimeType, modelInfo, walkSet, modelAnim);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderStateWithModelInfoImplCopyWith<_$HeaderStateWithModelInfoImpl>
      get copyWith => __$$HeaderStateWithModelInfoImplCopyWithImpl<
          _$HeaderStateWithModelInfoImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)
        withModelInfo,
    required TResult Function(SoundInfo sound) withSound,
    required TResult Function(DustTrailInfo dustTrailInfo) withDustTrail,
  }) {
    return withModelInfo(modelInfo, walkSet, modelAnim);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult? Function(SoundInfo sound)? withSound,
    TResult? Function(DustTrailInfo dustTrailInfo)? withDustTrail,
  }) {
    return withModelInfo?.call(modelInfo, walkSet, modelAnim);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult Function(SoundInfo sound)? withSound,
    TResult Function(DustTrailInfo dustTrailInfo)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withModelInfo != null) {
      return withModelInfo(modelInfo, walkSet, modelAnim);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(HeaderStateWithModelInfo value) withModelInfo,
    required TResult Function(HeaderStateWithSound value) withSound,
    required TResult Function(HeaderStateWithDustTrail value) withDustTrail,
  }) {
    return withModelInfo(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult? Function(HeaderStateWithSound value)? withSound,
    TResult? Function(HeaderStateWithDustTrail value)? withDustTrail,
  }) {
    return withModelInfo?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult Function(HeaderStateWithSound value)? withSound,
    TResult Function(HeaderStateWithDustTrail value)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withModelInfo != null) {
      return withModelInfo(this);
    }
    return orElse();
  }
}

abstract class HeaderStateWithModelInfo implements HeaderState {
  const factory HeaderStateWithModelInfo(
      {required final ModelInfo modelInfo,
      final WalkSet? walkSet,
      final ModelAnim? modelAnim}) = _$HeaderStateWithModelInfoImpl;

  ModelInfo get modelInfo;
  WalkSet? get walkSet;
  ModelAnim? get modelAnim;
  @JsonKey(ignore: true)
  _$$HeaderStateWithModelInfoImplCopyWith<_$HeaderStateWithModelInfoImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HeaderStateWithSoundImplCopyWith<$Res> {
  factory _$$HeaderStateWithSoundImplCopyWith(_$HeaderStateWithSoundImpl value,
          $Res Function(_$HeaderStateWithSoundImpl) then) =
      __$$HeaderStateWithSoundImplCopyWithImpl<$Res>;
  @useResult
  $Res call({SoundInfo sound});
}

/// @nodoc
class __$$HeaderStateWithSoundImplCopyWithImpl<$Res>
    extends _$HeaderStateCopyWithImpl<$Res, _$HeaderStateWithSoundImpl>
    implements _$$HeaderStateWithSoundImplCopyWith<$Res> {
  __$$HeaderStateWithSoundImplCopyWithImpl(_$HeaderStateWithSoundImpl _value,
      $Res Function(_$HeaderStateWithSoundImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? sound = null,
  }) {
    return _then(_$HeaderStateWithSoundImpl(
      sound: null == sound
          ? _value.sound
          : sound // ignore: cast_nullable_to_non_nullable
              as SoundInfo,
    ));
  }
}

/// @nodoc

class _$HeaderStateWithSoundImpl
    with DiagnosticableTreeMixin
    implements HeaderStateWithSound {
  const _$HeaderStateWithSoundImpl({required this.sound});

  @override
  final SoundInfo sound;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HeaderState.withSound(sound: $sound)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HeaderState.withSound'))
      ..add(DiagnosticsProperty('sound', sound));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderStateWithSoundImpl &&
            (identical(other.sound, sound) || other.sound == sound));
  }

  @override
  int get hashCode => Object.hash(runtimeType, sound);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderStateWithSoundImplCopyWith<_$HeaderStateWithSoundImpl>
      get copyWith =>
          __$$HeaderStateWithSoundImplCopyWithImpl<_$HeaderStateWithSoundImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)
        withModelInfo,
    required TResult Function(SoundInfo sound) withSound,
    required TResult Function(DustTrailInfo dustTrailInfo) withDustTrail,
  }) {
    return withSound(sound);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult? Function(SoundInfo sound)? withSound,
    TResult? Function(DustTrailInfo dustTrailInfo)? withDustTrail,
  }) {
    return withSound?.call(sound);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult Function(SoundInfo sound)? withSound,
    TResult Function(DustTrailInfo dustTrailInfo)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withSound != null) {
      return withSound(sound);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(HeaderStateWithModelInfo value) withModelInfo,
    required TResult Function(HeaderStateWithSound value) withSound,
    required TResult Function(HeaderStateWithDustTrail value) withDustTrail,
  }) {
    return withSound(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult? Function(HeaderStateWithSound value)? withSound,
    TResult? Function(HeaderStateWithDustTrail value)? withDustTrail,
  }) {
    return withSound?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult Function(HeaderStateWithSound value)? withSound,
    TResult Function(HeaderStateWithDustTrail value)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withSound != null) {
      return withSound(this);
    }
    return orElse();
  }
}

abstract class HeaderStateWithSound implements HeaderState {
  const factory HeaderStateWithSound({required final SoundInfo sound}) =
      _$HeaderStateWithSoundImpl;

  SoundInfo get sound;
  @JsonKey(ignore: true)
  _$$HeaderStateWithSoundImplCopyWith<_$HeaderStateWithSoundImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$HeaderStateWithDustTrailImplCopyWith<$Res> {
  factory _$$HeaderStateWithDustTrailImplCopyWith(
          _$HeaderStateWithDustTrailImpl value,
          $Res Function(_$HeaderStateWithDustTrailImpl) then) =
      __$$HeaderStateWithDustTrailImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DustTrailInfo dustTrailInfo});
}

/// @nodoc
class __$$HeaderStateWithDustTrailImplCopyWithImpl<$Res>
    extends _$HeaderStateCopyWithImpl<$Res, _$HeaderStateWithDustTrailImpl>
    implements _$$HeaderStateWithDustTrailImplCopyWith<$Res> {
  __$$HeaderStateWithDustTrailImplCopyWithImpl(
      _$HeaderStateWithDustTrailImpl _value,
      $Res Function(_$HeaderStateWithDustTrailImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dustTrailInfo = null,
  }) {
    return _then(_$HeaderStateWithDustTrailImpl(
      dustTrailInfo: null == dustTrailInfo
          ? _value.dustTrailInfo
          : dustTrailInfo // ignore: cast_nullable_to_non_nullable
              as DustTrailInfo,
    ));
  }
}

/// @nodoc

class _$HeaderStateWithDustTrailImpl
    with DiagnosticableTreeMixin
    implements HeaderStateWithDustTrail {
  const _$HeaderStateWithDustTrailImpl({required this.dustTrailInfo});

  @override
  final DustTrailInfo dustTrailInfo;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'HeaderState.withDustTrail(dustTrailInfo: $dustTrailInfo)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'HeaderState.withDustTrail'))
      ..add(DiagnosticsProperty('dustTrailInfo', dustTrailInfo));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$HeaderStateWithDustTrailImpl &&
            (identical(other.dustTrailInfo, dustTrailInfo) ||
                other.dustTrailInfo == dustTrailInfo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, dustTrailInfo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$HeaderStateWithDustTrailImplCopyWith<_$HeaderStateWithDustTrailImpl>
      get copyWith => __$$HeaderStateWithDustTrailImplCopyWithImpl<
          _$HeaderStateWithDustTrailImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)
        withModelInfo,
    required TResult Function(SoundInfo sound) withSound,
    required TResult Function(DustTrailInfo dustTrailInfo) withDustTrail,
  }) {
    return withDustTrail(dustTrailInfo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? empty,
    TResult? Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult? Function(SoundInfo sound)? withSound,
    TResult? Function(DustTrailInfo dustTrailInfo)? withDustTrail,
  }) {
    return withDustTrail?.call(dustTrailInfo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function(
            ModelInfo modelInfo, WalkSet? walkSet, ModelAnim? modelAnim)?
        withModelInfo,
    TResult Function(SoundInfo sound)? withSound,
    TResult Function(DustTrailInfo dustTrailInfo)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withDustTrail != null) {
      return withDustTrail(dustTrailInfo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Empty value) empty,
    required TResult Function(HeaderStateWithModelInfo value) withModelInfo,
    required TResult Function(HeaderStateWithSound value) withSound,
    required TResult Function(HeaderStateWithDustTrail value) withDustTrail,
  }) {
    return withDustTrail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Empty value)? empty,
    TResult? Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult? Function(HeaderStateWithSound value)? withSound,
    TResult? Function(HeaderStateWithDustTrail value)? withDustTrail,
  }) {
    return withDustTrail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Empty value)? empty,
    TResult Function(HeaderStateWithModelInfo value)? withModelInfo,
    TResult Function(HeaderStateWithSound value)? withSound,
    TResult Function(HeaderStateWithDustTrail value)? withDustTrail,
    required TResult orElse(),
  }) {
    if (withDustTrail != null) {
      return withDustTrail(this);
    }
    return orElse();
  }
}

abstract class HeaderStateWithDustTrail implements HeaderState {
  const factory HeaderStateWithDustTrail(
          {required final DustTrailInfo dustTrailInfo}) =
      _$HeaderStateWithDustTrailImpl;

  DustTrailInfo get dustTrailInfo;
  @JsonKey(ignore: true)
  _$$HeaderStateWithDustTrailImplCopyWith<_$HeaderStateWithDustTrailImpl>
      get copyWith => throw _privateConstructorUsedError;
}
